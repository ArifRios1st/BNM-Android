#include "BNM.hpp"
#include "BNM_data/utf8.h"

#define DO_API(r, n, p) auto (n) = (r (*) p)BNM_dlsym(BNM_Internal::dlLib, OBFUSCATE_BNM(#n))
namespace BNM_Internal {
    using namespace BNM;

    // Internal variables
    static bool LibLoaded = false;
    static void *dlLib{};
    static bool hardBypass = false;
    static const char *LibAbsolutePath{};
    static BNM_PTR LibAbsoluteAddress{};
    static bool HasImageGetCls = false;
    static void (*OnIl2CppLoadedEvent)(){};

    // Methods for new classes and for basic mode
    AssemblyVector *(*Assembly$$GetAllAssemblies)(){};
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES // Speed up IDE if c++ lower then c++17

    // Vector with all new classes that BNM need add at runtime
    static std::vector<NEW_CLASSES::NewClass *> *classes4Add{};

    // Dummy .ctor that just calling base .ctor
    void DefaultConstructor(IL2CPP::Il2CppObject* instance) {
        LoadClass(instance->klass->parent).GetMethodByName(OBFUSCATE_BNM(".ctor"), 0)[instance]();
    }
    void DefaultConstructorInvoke(IL2CPP::Il2CppMethodPointer, IL2CPP::MethodInfo*, IL2CPP::Il2CppObject *instance, void**) { DefaultConstructor(instance); }


    IL2CPP::Il2CppClass *(*old_Class$$FromIl2CppType)(IL2CPP::Il2CppType *type){};
    IL2CPP::Il2CppClass *Class$$FromIl2CppType(IL2CPP::Il2CppType *type);

    IL2CPP::Il2CppClass *(*old_Class$$FromName)(IL2CPP::Il2CppImage *image, const char *ns, const char *name){};
    IL2CPP::Il2CppClass *Class$$FromName(IL2CPP::Il2CppImage *image, const char *namespaze, const char *name);

    // Struct for Il2CppType for classes to check is it is generated by BNM
    struct BNMTypeData {
        BNMTypeData() = default;
        BNM_PTR bnm = -0x424e4d;
        IL2CPP::Il2CppClass *cls{};
    };

    void InitNewClasses();
#if UNITY_VER <= 174
    // Need hook `Get image from index` and `load assembly`, because in unity 2017 and lower image and assembly are stored by indexes

    IL2CPP::Il2CppImage *(*old_GetImageFromIndex)(IL2CPP::ImageIndex index);
    IL2CPP::Il2CppImage *new_GetImageFromIndex(IL2CPP::ImageIndex index);

    IL2CPP::Il2CppAssembly *Assembly$$Load(const char *name);
#endif

#endif
    void (*old_Image$$GetTypes)(IL2CPP::Il2CppImage *image, bool exportedOnly, ClassVector *target){};
    void Image$$GetTypes(IL2CPP::Il2CppImage *image, bool exportedOnly, ClassVector *target);

    void (*Class$$Init)(IL2CPP::Il2CppClass *klass){};

    void (*old_BNM_il2cpp_init)(const char *);
    void BNM_il2cpp_init(const char *domain_name);

    void InitIl2cppMethods();

#ifndef BNM_DISABLE_AUTO_LOAD
    [[maybe_unused]] __attribute__((constructor)) void PrepareBNM();
#endif

    bool InitDlLib(void *dl, const char *path = nullptr, bool external = false);

    // Fast utf8 implementation for converting monoString
    typedef std::basic_string<IL2CPP::Il2CppChar> string16;
    std::string Utf16ToUtf8(IL2CPP::Il2CppChar *utf16String, size_t length) {
        std::string utf8String;
        utf8String.reserve(length);
        utf8::unchecked::utf16to8(utf16String, utf16String + length, std::back_inserter(utf8String));
        return utf8String;
    }
    string16 Utf8ToUtf16(const char *utf8String, size_t length) {
        string16 utf16String;
        if (utf8::is_valid(utf8String, utf8String + length)) {
            utf16String.reserve(length);
            utf8::unchecked::utf8to16(utf8String, utf8String + length, std::back_inserter(utf16String));
        }
        return utf16String;
    }
}
namespace BNM {
    // Get/Set internal data
    bool Il2cppLoaded() { return BNM_Internal::LibLoaded; }
    void SetIl2CppLoadEvent(void (*event)()) { BNM_Internal::OnIl2CppLoadedEvent = event; }

    // Safe convert std::string to const char *
    char *str2char(const std::string &str) {
        size_t size = str.end() - str.begin();
        if (str.c_str()[size]) {
            auto c = (char *)malloc(size);
            std::copy(str.begin(), str.end(), c);
            c[size] = 0;
            return c;
        }
        return (char *)str.c_str();
    }

    namespace MONO_STRUCTS {
        std::string monoString::get_string() {
            if (!this) return OBFUSCATE_BNM("ERROR: monoString is null");
            if (!isAllocated(chars)) return OBFUSCATE_BNM("ERROR: chars is null");
            if (!length) return OBFUSCATE_BNM("ERROR: str is empty");
            return BNM_Internal::Utf16ToUtf8(chars, length);
        }
        std::string monoString::str() { return get_string(); }

        const char *monoString::get_const_char() { return str2char(get_string()); }
        const char *monoString::c_str() { return get_const_char(); }

        std::string monoString::get_string_old() {
            if (!this) return OBFUSCATE_BNM("ERROR: monoString is null");
            if (!isAllocated(chars)) return OBFUSCATE_BNM("ERROR: chars is null");
            if (!length) return OBFUSCATE_BNM("ERROR: str is empty");
            return std::wstring_convert<std::codecvt_utf8<IL2CPP::Il2CppChar>, IL2CPP::Il2CppChar>().to_bytes((IL2CPP::Il2CppChar *)chars);
        }
        [[maybe_unused]] std::string monoString::strO() { return get_string_old(); }

        [[maybe_unused]] unsigned int monoString::getHash() {
            if (!this || !isAllocated(chars)) return 0;
            IL2CPP::Il2CppChar *p = chars;
            unsigned int h = 0;
            for (int i = 0; i < length; ++i)
                h = (h << 5) - h + *p; p++;
            return h;
        }

        // Create basic c# string like il2cpp
        monoString *monoString::Create(const char *str) {
            const size_t length = strlen(str);
            const size_t utf16Size = sizeof(IL2CPP::Il2CppChar) * length;
            auto ret = (monoString *)malloc(sizeof(monoString) + utf16Size);
            ret->length = (int)length;
            auto u16 = BNM_Internal::Utf8ToUtf16(str, ret->length);
            memcpy(ret->chars, &u16[0], utf16Size);
            u16.clear();
            auto empty = Empty();
            if (empty) ret->klass = empty->klass;
            return (monoString *)ret;
        }
        [[maybe_unused]] monoString *monoString::Create(const std::string &str) { return Create(str2char(str)); }

        [[maybe_unused]] monoString *monoString::Empty() { return LoadClass(OBFUSCATES_BNM("System"), OBFUSCATES_BNM("String")).GetFieldByName(OBFUSCATES_BNM("Empty")).cast<monoString *>()(); }
    }

    /*** LoadClass ***/
    LoadClass::LoadClass(const IL2CPP::Il2CppClass *clazz) { klass = (IL2CPP::Il2CppClass *)clazz; }

    LoadClass::LoadClass(const IL2CPP::Il2CppObject *obj) {
        if (!obj) return;
        klass = obj->klass;
    }

    [[maybe_unused]] LoadClass::LoadClass(const IL2CPP::Il2CppType *type) {
        if (!type) return;
        DO_API(IL2CPP::Il2CppClass *, il2cpp_class_from_il2cpp_type, (const IL2CPP::Il2CppType *));
        klass = il2cpp_class_from_il2cpp_type(type);
    }

    [[maybe_unused]] LoadClass::LoadClass(const MonoType *type) {
        if (!type) return;
        DO_API(IL2CPP::Il2CppClass *, il2cpp_class_from_il2cpp_type, (const IL2CPP::Il2CppType *));
        klass = il2cpp_class_from_il2cpp_type(type->type);
    }

    [[maybe_unused]] LoadClass::LoadClass(RuntimeTypeGetter type) { klass = type; }

    LoadClass::LoadClass(const std::string &namespaze, const std::string &name) {
        DO_API(IL2CPP::Il2CppImage *, il2cpp_assembly_get_image, (IL2CPP::Il2CppAssembly *));

        auto assemblies = BNM_Internal::Assembly$$GetAllAssemblies();

        for (auto assembly : *assemblies) {
            // Get image from assembly
            auto image = il2cpp_assembly_get_image(assembly);

            // Get all types of image
            ClassVector classes;
            BNM_Internal::Image$$GetTypes(image, false, &classes);

            for (auto cls : classes) {
                if (!cls) continue;

                // Init class if it not initialized
                BNM_Internal::Class$$Init(cls);

                if (cls->name == name && cls->namespaze == namespaze) {
                    klass = cls;
                    break;
                }
            }
            classes.clear(); classes.shrink_to_fit();
            if (klass) break;
        }
        if (!klass) LOGWBNM(OBFUSCATE_BNM("Class: [%s]::[%s] - not found"), namespaze.c_str(), name.c_str());
    }

    LoadClass::LoadClass(const std::string &namespaze, const std::string &name, const std::string &dllName) {
        DO_API(IL2CPP::Il2CppImage *, il2cpp_assembly_get_image, (const IL2CPP::Il2CppAssembly *));

        IL2CPP::Il2CppImage *image = nullptr;
        auto assemblies = BNM_Internal::Assembly$$GetAllAssemblies();

        // Try find image
        for (auto assembly : *assemblies)
            if (dllName == il2cpp_assembly_get_image(assembly)->name) {
                image = il2cpp_assembly_get_image(assembly);
                break;
            }

        // Check is image found
        if (!image) {
            LOGWBNM(OBFUSCATE_BNM("Class: [%s]::[%s]::[%s] - dll not found"), dllName.c_str(), namespaze.c_str(), name.c_str());
            klass = nullptr;
            return;
        }

        // Get all types of image
        ClassVector classes;
        BNM_Internal::Image$$GetTypes(image, false, &classes);

        // Try find type
        for (auto cls : classes) {
            if (!cls) continue;

            // Init class if it not initialized
            BNM_Internal::Class$$Init(cls);

            // Check is needed class
            if (cls->name == name && cls->namespaze == namespaze) {
                klass = cls;
                break;
            }
        }

        // Clear classes vector
        classes.clear(); classes.shrink_to_fit();

        if (!klass) LOGWBNM(OBFUSCATE_BNM("Class: [%s]::[%s]::[%s] - not found"), dllName.c_str(), namespaze.c_str(), name.c_str());
    }

    [[maybe_unused]] std::vector<LoadClass> LoadClass::GetInnerClasses(bool includeParent) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        std::vector<LoadClass> ret;
        auto curClass = klass;

        do {
            // Add classes to vector
            for (int i = 0; i < curClass->nested_type_count; ++i) ret.emplace_back(curClass->nestedTypes[i]);

            // Switch to parent if need
            if (includeParent) curClass = curClass->parent;
            else curClass = nullptr;

        } while (curClass);

        return ret;
    }

    [[maybe_unused]] std::vector<IL2CPP::FieldInfo *> LoadClass::GetFieldsInfo(bool includeParent) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        std::vector<IL2CPP::FieldInfo *> ret;
        auto curClass = klass;

        do {
            // Add fields to vector
            for (int i = 0; i < curClass->field_count; ++i) ret.emplace_back(curClass->fields + i);

            // Switch to parent if need
            if (includeParent) curClass = curClass->parent;
            else curClass = nullptr;
        } while (curClass);

        return ret;
    }

    [[maybe_unused]] std::vector<IL2CPP::MethodInfo *> LoadClass::GetMethodsInfo(bool includeParent) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        std::vector<IL2CPP::MethodInfo *> ret;
        auto curClass = klass;

        do {
            // Add methods to vector
            for (int i = 0; i < curClass->method_count; ++i) ret.emplace_back(Method<void>(curClass->methods[i]).GetInfo());

            // Switch to parent if need
            if (includeParent) curClass = curClass->parent;
            else curClass = nullptr;

        } while (curClass);

        return ret;
    }

    Method<void> LoadClass::GetMethodByName(const std::string &name, int parameters) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        Method<void> ret{};

        // Get all methods
        auto methods = GetMethodsInfo(true);

        // Try find method
        for (auto method : methods)
            if (name == method->name && (method->parameters_count == parameters || parameters == -1)) {
                ret = method;
                break;
            }

        // Clear methods vector
        methods.clear(); methods.shrink_to_fit();

        // Warn non found
        if (!ret) LOGWBNM(OBFUSCATE_BNM("Method: [%s]::[%s].[%s], %d - not found"), klass->namespaze, klass->name, name.c_str(), parameters);

        return ret;
    }

    Method<void> LoadClass::GetMethodByName(const std::string &name, const std::vector<std::string> &parametersName) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        DO_API(const char *, il2cpp_method_get_param_name, (IL2CPP::MethodInfo *method, uint32_t index));

        Method<void> ret{};

        // Get all methods
        auto methods = GetMethodsInfo(true);

        size_t parameters = parametersName.size();

        // Try find method
        for (auto method : methods)
            if (name == method->name && (method->parameters_count == parameters)) {
                bool ok = true;

                // Check params
                for (int g = 0; g < parameters; ++g)
                    if (il2cpp_method_get_param_name(method, g) != parametersName[g]) {
                        // Name not same, break for
                        ok = false;
                        break;
                    }

                // Found, break for
                if (ok) {
                    ret = method;
                    break;
                }
            }

        // Clear methods vector
        methods.clear(); methods.shrink_to_fit();

        // Warn non found
        if (!ret) LOGWBNM(OBFUSCATE_BNM("Method: [%s]::[%s].[%s], %d - not found (using params_names)"), klass->namespaze, klass->name, name.c_str(), parameters);

        return ret;
    }

    Method<void> LoadClass::GetMethodByName(const std::string &name, const std::vector<RuntimeTypeGetter> &parametersType) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        DO_API(IL2CPP::Il2CppClass *, il2cpp_class_from_il2cpp_type, (const IL2CPP::Il2CppType *));

        Method<void> ret{};

        // Get all methods
        auto methods = GetMethodsInfo(true);

        size_t parameters = parametersType.size();

        // Try find method
        for (auto method : methods)
            if (name == method->name && (method->parameters_count == parameters)) {
                bool ok = true;

                // Check params
                for (int g = 0; g < parameters; ++g) {
#if UNITY_VER < 212
                    auto param = method->parameters + g;
                    auto cls = il2cpp_class_from_il2cpp_type(param->parameter_type);
#else
                    auto param = method->parameters[g];
                    auto cls = il2cpp_class_from_il2cpp_type(param);
#endif
                    if (cls == ((RuntimeTypeGetter) parametersType[g]).ToIl2CppClass()) {
                        // Type not same, break for
                        ok = false;
                        break;
                    }
                }

                // Found, break for
                if (ok) {
                    ret = method;
                    break;
                }
            }

        // Clear methods vector
        methods.clear(); methods.shrink_to_fit();

        // Warn non found
        if (!ret) LOGWBNM(OBFUSCATE_BNM("Method: [%s]::[%s].[%s], %d - not found"), klass->namespaze, klass->name, name.c_str(), parameters);

        return ret;
    }

    [[maybe_unused]] Property<bool> LoadClass::GetPropertyByName(const std::string &name, bool warning) {
        if (!klass) return {};
        TryInit();
        auto get = GetMethodByName(OBFUSCATES_BNM("get_") + name);
        auto set = GetMethodByName(OBFUSCATES_BNM("set_") + name);
        if (!get && !set) {
            LOGWBNM(OBFUSCATE_BNM("Property %s.[%s] not found"), str().c_str(), name.c_str());
            return {};
        }
        if (!get && warning)
            LOGWBNM(OBFUSCATE_BNM("Property %s.[%s] without get"), str().c_str(), name.c_str());
        if (!set && warning)
            LOGWBNM(OBFUSCATE_BNM("Property %s.[%s] without set"), str().c_str(), name.c_str());
        return {get, set};
    }

    [[maybe_unused]] LoadClass LoadClass::GetInnerClass(const std::string &name) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        LoadClass ret{};

        // Get all inner classes
        auto classes = GetInnerClasses(true);

        // Try find class
        for (auto cls : classes)
            if (name == cls.klass->name) {
                ret = cls;
                break;
            }

        // Clear classes vector
        classes.clear(); classes.shrink_to_fit();

        // Warn non found
        if (!ret.klass) LOGWBNM(OBFUSCATE_BNM("InnerClass: [%s]::[%s]::[%s] - not found"), klass->namespaze, klass->name, name.c_str());

        return ret;
    }

    Field<int> LoadClass::GetFieldByName(const std::string &name) const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        Field<int> ret{};

        // Get all fields
        auto fields = GetFieldsInfo(true);

        // Try find class
        for (auto field : fields)
            if (name == field->name) {
                ret = field;
                break;
            }

        // Clear fields vector
        fields.clear(); fields.shrink_to_fit();

        // Warn non found
        if (!ret.Initialized()) LOGWBNM(OBFUSCATE_BNM("Field: [%s]::[%s].(%s) - not found"), klass->namespaze, klass->name, name.c_str());

        return ret;
    }

    [[maybe_unused]] LoadClass LoadClass::GetArrayClass() const {
        if (!klass) return {};
        TryInit(); // Try init klass in it not initialized

        DO_API(IL2CPP::Il2CppClass *, il2cpp_array_class_get, (IL2CPP::Il2CppClass *, uint32_t));

        return il2cpp_array_class_get(klass, 1);
    }

    IL2CPP::Il2CppType *LoadClass::GetIl2CppType() const {
        if (!klass) return nullptr;
        TryInit(); // Try init klass in it not initialized

#if UNITY_VER > 174
        return (IL2CPP::Il2CppType *)&klass->byval_arg;
#else
        return (IL2CPP::Il2CppType *)klass->byval_arg;
#endif
    }

    [[maybe_unused]] MonoType *LoadClass::GetMonoType() const {
        if (!klass) return nullptr;
        TryInit(); // Try init klass in it not initialized

        DO_API(IL2CPP::Il2CppObject *, il2cpp_type_get_object, (IL2CPP::Il2CppType *));

        return (MonoType *) il2cpp_type_get_object(GetIl2CppType());
    }

    IL2CPP::Il2CppClass *LoadClass::GetIl2CppClass() const {
        TryInit(); // Try init klass in it not initialized
        return klass;
    }

    void *LoadClass::CreateNewInstance() const {
        if (!klass) return nullptr;
        TryInit(); // Try init klass in it not initialized

        if ((klass->flags & (0x00000080 | 0x00000020))) // TYPE_ATTRIBUTE_ABSTRACT | TYPE_ATTRIBUTE_INTERFACE
            LOGWBNM(OBFUSCATE_BNM("You trying to create instance of abstract or interface class %s?\nIn c# this is impossible."), str().c_str());

        DO_API(IL2CPP::Il2CppObject *, il2cpp_object_new, (IL2CPP::Il2CppClass *));

        return (void *) il2cpp_object_new(klass);
    }


    [[maybe_unused]] std::string LoadClass::str() const {
        if (klass) {
            TryInit(); // Try init klass in it not initialized
            return OBFUSCATES_BNM("[") + klass->image->name + OBFUSCATES_BNM("]::[") + klass->namespaze + OBFUSCATES_BNM("]::[") + klass->name + OBFUSCATES_BNM("]");
        }
        return OBFUSCATES_BNM("Uninitialized class");
    }

    // Try init klass if it not initialized
    void LoadClass::TryInit() const { if (klass) BNM_Internal::Class$$Init(klass); }

    IL2CPP::Il2CppObject *LoadClass::ObjBox(IL2CPP::Il2CppClass *klass, void *data) {
        DO_API(IL2CPP::Il2CppObject *, il2cpp_value_box, (IL2CPP::Il2CppClass *, void *));
        return il2cpp_value_box(klass, data);
    }

    IL2CPP::Il2CppObject *LoadClass::ObjNew(IL2CPP::Il2CppClass *cls) {
        DO_API(IL2CPP::Il2CppObject *, il2cpp_object_new, (IL2CPP::Il2CppClass *));
        return il2cpp_object_new(cls);
    }

    IL2CPP::Il2CppArray *LoadClass::ArrayNew(IL2CPP::Il2CppClass *cls, IL2CPP::il2cpp_array_size_t length) {
        DO_API(IL2CPP::Il2CppArray *, il2cpp_array_new, (IL2CPP::Il2CppClass *, IL2CPP::il2cpp_array_size_t));
        return il2cpp_array_new(cls, length);
    }


    /*** RuntimeTypeGetter ***/
    LoadClass RuntimeTypeGetter::ToLC() {
        if (!loadedClass.klass) {
            loadedClass = LoadClass(namespaze, name);
            if (isArray) loadedClass = LoadClass(loadedClass.GetArrayClass());
        }
        return loadedClass;
    }
    RuntimeTypeGetter::operator LoadClass() { return ToLC(); }

    IL2CPP::Il2CppType *RuntimeTypeGetter::ToIl2CppType() { return ToLC().GetIl2CppType(); }
    RuntimeTypeGetter::operator IL2CPP::Il2CppType*() { return ToIl2CppType(); }

    IL2CPP::Il2CppClass *RuntimeTypeGetter::ToIl2CppClass() { return ToLC().GetIl2CppClass(); }
    RuntimeTypeGetter::operator IL2CPP::Il2CppClass*() { return ToIl2CppClass(); }

    /*** RuntimeMethodGetter ***/
    Method<void> RuntimeMethodGetter::ToMethod() {
        if (!loadedMethod) {
            if (!argTypes.empty()) loadedMethod = type.ToLC().GetMethodByName(name, argTypes);
            if (!loadedMethod && !argNames.empty()) loadedMethod = type.ToLC().GetMethodByName(name, argNames);
            if (!loadedMethod) loadedMethod = type.ToLC().GetMethodByName(name, args);
        }
        return loadedMethod;
    }
    RuntimeMethodGetter::operator Method<void>() { return ToMethod(); }

    // For thread static fields
    namespace PRIVATE_FILED_UTILS {
        void GetStaticValue(IL2CPP::FieldInfo *info, void *value) {
            DO_API(void, il2cpp_field_static_get_value, (IL2CPP::FieldInfo *, void *));
            return il2cpp_field_static_get_value(info, value);
        }
        void SetStaticValue(IL2CPP::FieldInfo *info, void *value) {
            DO_API(void, il2cpp_field_static_set_value, (IL2CPP::FieldInfo *, void *));
            return il2cpp_field_static_set_value(info, value);
        }
    }

    /*** BNM methods ***/
    using namespace MONO_STRUCTS;
    [[maybe_unused]] bool AttachIl2Cpp() {
        if (CurrentIl2CppThread()) return false;
        DO_API(IL2CPP::Il2CppDomain *, il2cpp_domain_get, ());
        DO_API(IL2CPP::Il2CppThread *, il2cpp_thread_attach, (IL2CPP::Il2CppDomain *));
        il2cpp_thread_attach(il2cpp_domain_get());
        return true;
    }

    [[maybe_unused]] IL2CPP::Il2CppThread *CurrentIl2CppThread() {
        DO_API(IL2CPP::Il2CppThread *, il2cpp_thread_current, ());
        return il2cpp_thread_current();
    }

    [[maybe_unused]] void DetachIl2Cpp() {
        auto thread = CurrentIl2CppThread();
        if (!thread) return;
        DO_API(void, il2cpp_thread_detach, (IL2CPP::Il2CppThread *));
        il2cpp_thread_detach(thread);
    }

    // Create basic c# string using il2cpp api
    monoString *CreateMonoString(const char *str) {
        DO_API(monoString *, il2cpp_string_new, (const char *str));
        return il2cpp_string_new(str);
    }
    [[maybe_unused]] monoString *CreateMonoString(const std::string &str) { return CreateMonoString(str2char(str)); }

    void *getExternMethod(const std::string &str) {
        DO_API(void *, il2cpp_resolve_icall, (const char *));
        auto c_str = str2char(str);
        auto ret = il2cpp_resolve_icall(c_str);
        if (!ret) LOGWBNM(OBFUSCATE_BNM("Can't get extern %s. Please check code."), c_str);
        return ret;
    }


    [[maybe_unused]] std::string GetLibIl2CppPath() {
        if (!BNM_Internal::dlLib) return OBFUSCATE_BNM("libil2cpp not found!");
        return BNM_Internal::LibAbsolutePath;
    }

    [[maybe_unused]] BNM_PTR GetLibIl2CppOffset() {
        return BNM_Internal::LibAbsoluteAddress;
    }

    void *offsetInLib(void *offsetInMemory) {
        Dl_info info; BNM_dladdr(offsetInMemory, &info);
        return (void *) ((BNM_PTR) offsetInMemory - (BNM_PTR) info.dli_fbase);
    }

    [[maybe_unused]] void *GetLibIl2CppDlInst() {
        return BNM_Internal::dlLib;
    }

    void InvokeHook(Method<int> m, void *newMet, void **oldMet) {
        if (m) InvokeHook(m.myInfo, newMet, oldMet);
    }

    void InvokeHook(IL2CPP::MethodInfo *m, void *newMet, void **oldMet) {
        if (!m) return;
        if (oldMet) *oldMet = (void *)m->methodPointer;
        m->methodPointer = (void(*)())newMet;
    }

    template<> bool IsA<IL2CPP::Il2CppObject *>(IL2CPP::Il2CppObject *object, IL2CPP::Il2CppClass *klass) {
        if (!object || !klass) return false;
        for (auto cls = object->klass; cls; cls = cls->parent) if (cls == klass) return true;
        return false;
    }

    namespace UNITY_STRUCTS {
        [[maybe_unused]] void *RaycastHit::get_Collider() const {
            if (!m_Collider || (BNM_PTR)m_Collider < 0) return {};
#if UNITY_VER > 174
            static void *(*FromId)(int);
            if (!FromId) InitResolveFunc(FromId, OBFUSCATE_BNM("UnityEngine.Object::FindObjectFromInstanceID"));
            return FromId(m_Collider);
#else
            return m_Collider;
#endif
        }
        [[maybe_unused]] const Vector3 Vector3::infinityVec = {std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity(), std::numeric_limits<float>::infinity()};
        [[maybe_unused]] const Vector3 Vector3::zero = {0.f, 0.f, 0.f};
        [[maybe_unused]] const Vector3 Vector3::one = {1.f, 1.f, 1.f};
        [[maybe_unused]] const Vector3 Vector3::up = {0.f, 1.f, 0.f};
        [[maybe_unused]] const Vector3 Vector3::down = {0.f, -1.f, 0.f};
        [[maybe_unused]] const Vector3 Vector3::left = {-1.f, 0.f, 0.f};
        [[maybe_unused]] const Vector3 Vector3::right = {1.f, 0.f, 0.f};
        [[maybe_unused]] const Vector3 Vector3::forward = {0.f, 0.f, 1.f};
        [[maybe_unused]] const Vector3 Vector3::back = {0.f, 0.f, -1.f};
    }

    namespace HexUtils {

        // Reverse hex string (form 001122 to 221100)
        std::string ReverseHexString(const std::string &hex) {
            std::string out;
            for (unsigned int i = 0; i < hex.length(); i += 2) out.insert(0, hex.substr(i, 2));
            return out;
        }

        // Remove spaces and 0x
        std::string FixHexString(std::string str) {
            std::string::size_type tmp;
            if (str.find(OBFUSCATE_BNM("0x")) != -1) {
                tmp = str.find(OBFUSCATE_BNM("0x"));
                str.replace(tmp, 2, OBFUSCATE_BNM(""));
            }
            for (int i = (int)str.length() - 1; i >= 0; --i)
                if (str[i] == ' ') str.erase(i, 1);
            return str;
        }

        // Convert hex string to value
        BNM_PTR HexStr2Value(const std::string &hex) { return strtoull(hex.c_str(), nullptr, 16); }

#if defined(__ARM_ARCH_7A__)

        // Check is assembly is `bl ...` or `b ...`
        bool IsBranchHex(const std::string &hex) {
            BNM_PTR hexW = HexStr2Value(ReverseHexString(FixHexString(hex)));
            return (hexW & 0x0A000000) == 0x0A000000;
        }

#elif defined(__aarch64__)

        // Check is assembly is `bl ...` or `b ...`
        bool IsBranchHex(const std::string &hex) {
            BNM_PTR hexW = HexStr2Value(ReverseHexString(FixHexString(hex)));
            return (hexW & 0xFC000000) == 0x14000000 || (hexW & 0xFC000000) == 0x94000000;
        }

#elif defined(__i386__) || defined(__x86_64__)

        // Check is assembly is `call ...`
        bool IsCallHex(const std::string &hex) { return hex.substr(0, 2) == OBFUSCATE_BNM("E8"); }

#else
#error "BNM support only arm64, arm, x86 and x86_64"
#endif

        // Read memory as hex string
        std::string ReadMemory(BNM_PTR address, size_t len) {
            char temp[len];
            memset(temp, 0, len);
            const size_t bufferLen = len * 2 + 1;
            char buffer[bufferLen];
            memset(buffer, 0, bufferLen);
            std::string ret;
            if (memcpy(temp, (void *)address, len) == nullptr) return ret;
            for (int i = 0; i < len; ++i)
                sprintf(&buffer[i * 2], OBFUSCATE_BNM("%02X"), (unsigned char) temp[i]);
            ret += buffer;
            return ret;
        }

        // Decoding b and bl and getting address that it jumps
        bool DecodeBranchOrCall(const std::string &hex, BNM_PTR offset, BNM_PTR &outOffset) {
#if defined(__ARM_ARCH_7A__) || defined(__aarch64__)
            if (!IsBranchHex(hex)) return false;
#if defined(__aarch64__)
            int add = 0;
#else
            int add = 8;
#endif
            // This is one line code based on capstone engine code
            outOffset = ((int32_t)(((((HexStr2Value(ReverseHexString(FixHexString(hex)))) & (((uint32_t)1 << 24) - 1) << 0) >> 0) << 2) << (32 - 26)) >> (32 - 26)) + offset + add;
#elif defined(__i386__) || defined(__x86_64__)
            if (!IsCallHex(hex)) return false;
            // offest + address from call + size of instruction
            outOffset = offset + HexStr2Value(ReverseHexString(FixHexString(hex)).substr(0, 8)) + 5;
#else
#error "BNM support only arm64, arm, x86 and x86_64"
            return false;
#endif
            return true;
        }

        // Parsing memory and trying to find b, or bl, or call
        // Than get address from it
        // index: 0 - first, 1 - second and etc.
        BNM_PTR FindNextJump(BNM_PTR start, int index) {
#if defined(__ARM_ARCH_7A__) || defined(__aarch64__)
            int offset = 0;
            std::string curHex = ReadMemory(start, 4);
            BNM_PTR outOffset = 0;
            bool out;
            while (!(out = DecodeBranchOrCall(curHex, start + offset, outOffset)) || index != 1) {
                offset += 4;
                curHex = ReadMemory(start + offset, 4);
                if (out) index--;
            }
            return outOffset;
#elif defined(__i386__) || defined(__x86_64__)
            int offset = 0;
            std::string curHex = ReadMemory(start, 1);
            BNM_PTR outOffset = 0;
            bool out;
            while (!(out = IsCallHex(curHex)) || index != 1) {
                offset += 1;
                curHex = ReadMemory(start + offset, 1);
                if (out) index--;
            }
            DecodeBranchOrCall(ReadMemory(start + offset, 5), start + offset, outOffset);
            return outOffset;
#endif
        }
    }
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
    namespace NEW_CLASSES {

        NewMethod::NewMethod() noexcept = default;
        NewField::NewField() noexcept = default;
        NewClass::NewClass() noexcept = default;

        void NewClass::AddNewField(NewField *field, bool isStatic) {
            if (!isStatic) fields4Add.push_back(field); // Just add non static
            else {
                // Calculate static field offset
                // Need specific field define order to make this work normally
                // Idk for what you can use static fields
                // But code is here and it work
                if (staticFieldOffset == 0x0) staticFieldsAddress = field->cppOffset;
                field->offset = staticFieldOffset;
                staticFieldOffset += field->size;
                fields4Add.push_back(field);
            }
        }

        void NewClass::AddNewMethod(NewMethod *method) {
            methods4Add.push_back(method); // Just add method
        }

        void AddNewClass(NEW_CLASSES::NewClass *klass) {
            if (!BNM_Internal::classes4Add)
                BNM_Internal::classes4Add = new std::vector<NEW_CLASSES::NewClass *>();
            // Just add class to all new classes list
            BNM_Internal::classes4Add->push_back(klass);
        }
    }
#endif

    [[maybe_unused]] void HardBypass(JNIEnv *env) {
        if (!env || BNM_Internal::dlLib || BNM_Internal::hardBypass) return;
        BNM_Internal::hardBypass = true;

        // Get path to dir with libs using jni
        jclass activityThread = env->FindClass(OBFUSCATE_BNM("android/app/ActivityThread"));
        auto context = env->CallObjectMethod(env->CallStaticObjectMethod(activityThread, env->GetStaticMethodID(activityThread, OBFUSCATE_BNM("currentActivityThread"), OBFUSCATE_BNM("()Landroid/app/ActivityThread;"))), env->GetMethodID(activityThread, OBFUSCATE_BNM("getApplication"), OBFUSCATE_BNM("()Landroid/app/Application;")));
        auto appInfo = env->CallObjectMethod(context, env->GetMethodID(env->GetObjectClass(context), OBFUSCATE_BNM("getApplicationInfo"), OBFUSCATE_BNM("()Landroid/content/pm/ApplicationInfo;")));
        std::string path = env->GetStringUTFChars((jstring)env->GetObjectField(appInfo, env->GetFieldID(env->GetObjectClass(appInfo), OBFUSCATE_BNM("nativeLibraryDir"), OBFUSCATE_BNM("Ljava/lang/String;"))), nullptr);

        // Try load il2cpp by this path
        auto libPath = str2char(path + OBFUSCATE_BNM("/libil2cpp.so"));
        auto dl = BNM_dlopen(libPath, RTLD_LAZY);
        if (!BNM_Internal::InitDlLib(dl, libPath)) LOGEBNM(OBFUSCATE_BNM("Can't hard bypass!"));
    }

    namespace External {
        [[maybe_unused]] void LoadBNM(void *dl) {
            if (BNM_Internal::InitDlLib(dl, nullptr, true)) {
                BNM_Internal::InitIl2cppMethods(); // Get some methods and hook them
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
                BNM_Internal::InitNewClasses(); // Make new classes and add them to il2cpp
#endif
                BNM_Internal::LibLoaded = true; // Set LibLoaded to true

                // Call il2cpp load event
                if (BNM_Internal::OnIl2CppLoadedEvent) {

                    // Because we can't 100% be sure that user call this method from il2cpp thread, need check and Attach even if he do this
                    bool needReattach = BNM::CurrentIl2CppThread();
                    if (!needReattach) BNM::AttachIl2Cpp();

                    BNM_Internal::OnIl2CppLoadedEvent();

                    // Reattach if it been attached and detach otherwise
                    if (needReattach) BNM::AttachIl2Cpp();
                    else BNM::DetachIl2Cpp();
                }
            } else LOGWBNM(OBFUSCATE_BNM("[External::LoadBNM] dl is null or wrong, can't load BNM"));
        }
        [[maybe_unused]] void ForceLoadBNM(void *dl) {
            BNM_Internal::dlLib = dl; // Force set dl
            BNM_Internal::InitIl2cppMethods(); // Get some methods and hook them
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
            BNM_Internal::InitNewClasses(); // Make new classes and add them to il2cpp
#endif
            BNM_Internal::LibLoaded = true; // Set LibLoaded to true

            // Call il2cpp load event
            if (BNM_Internal::OnIl2CppLoadedEvent) {

                // Because we can't 100% be sure that user call this method from il2cpp thread, need check and Attach even if he do this
                bool needReattach = BNM::CurrentIl2CppThread();
                if (!needReattach) BNM::AttachIl2Cpp();

                BNM_Internal::OnIl2CppLoadedEvent();

                // Reattach if it been attached and detach otherwise
                if (needReattach) BNM::AttachIl2Cpp();
                else BNM::DetachIl2Cpp();
            }
        }
    }
}
namespace BNM_Internal {
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
    struct { // Struct for fast parsing and finding classes by image

        // Add class to image
        void addClass(IL2CPP::Il2CppImage *image, IL2CPP::Il2CppClass *cls) {
            return addClass((BNM_PTR)image, cls);
        }
        void addClass(BNM_PTR image, IL2CPP::Il2CppClass *cls) {
            map[image].emplace_back(cls);
        }

        // Iterate all classes added to image
        void forEachByImage(IL2CPP::Il2CppImage *image, const std::function<bool(IL2CPP::Il2CppClass *)> &func) {
            return forEachByImage((BNM_PTR)image, func);
        }
        void forEachByImage(BNM_PTR image, const std::function<bool(IL2CPP::Il2CppClass *)> &func) {
            if (map[image].empty()) return;
            for (auto &item: map[image]) {
                if (func(item))
                    break;
            }
        }

        // Iterate all images and classes added to it
        void forEach(const std::function<bool(IL2CPP::Il2CppImage *, std::vector<IL2CPP::Il2CppClass *>)> &func) {
            for (auto [img, classes] : map) {
                if (func((IL2CPP::Il2CppImage *)img, classes))
                    break;
            }
        }
    private:
        std::map<BNM_PTR, std::vector<IL2CPP::Il2CppClass *>> map;
    } BNMClassesMap;

#define BNM_I2C_NEW(type, ...) new IL2CPP::type(__VA_ARGS__)

    // Get loaded image or create new and add it to list
    IL2CPP::Il2CppImage *makeImage(NEW_CLASSES::NewClass *cls) {

        // Create new image
        auto newImg = BNM_I2C_NEW(Il2CppImage);

        // Make name without .dll
        auto nameLen = strlen(cls->dllName) + 1;
        newImg->nameNoExt = new char[nameLen];
        memset((void *)newImg->nameNoExt, 0, nameLen);
        strcpy((char *)newImg->nameNoExt, cls->dllName);


        // Make name with .dll
        auto extLen = nameLen + 4;
        newImg->name = new char[extLen];
        memset((void *)newImg->name, 0, extLen);
        strcpy((char *)newImg->name, cls->dllName);
        strcat((char *)newImg->name, OBFUSCATE_BNM(".dll"));

#if UNITY_VER > 182
        newImg->assembly = nullptr;
        newImg->customAttributeCount = 0;
#if UNITY_VER < 201
        newImg->customAttributeStart = -1;
#endif
#endif

#if UNITY_VER > 201

        // Generate dummy Il2CppImageDefinition
        auto handle = (IL2CPP::Il2CppImageDefinition *)malloc(sizeof(IL2CPP::Il2CppImageDefinition));
        handle->typeStart = -1;
        handle->exportedTypeStart = -1;
        handle->typeCount = 0;
        handle->exportedTypeCount = 0;
        handle->nameIndex = -1;
        handle->assemblyIndex = -1;
        handle->customAttributeCount = 0;
        handle->customAttributeStart = -1;
        newImg->metadataHandle = (decltype(newImg->metadataHandle))handle;
#else
        // Set to -1 for disabling parsing by il2cpp
        newImg->typeStart = -1;
        newImg->exportedTypeStart = -1;
#endif
        // Init variables
        newImg->typeCount = 0;
        newImg->exportedTypeCount = 0;
        newImg->token = 1;

        // Create new assembly for image
        auto newAsm = BNM_I2C_NEW(Il2CppAssembly);
#if UNITY_VER > 174
        // Set assembly and image
        newAsm->image = newImg;
        newAsm->image->assembly = newAsm;
        newAsm->aname.name = newImg->name;
#else
        // Negative value for disabling parsing by il2cpp
        static int newAsmCount = 1;
        newImg->assemblyIndex = newAsm->imageIndex = -newAsmCount;
        newAsmCount++;
#endif
        // Init those variables just in case
        newAsm->aname.major = 0;
        newAsm->aname.minor = 0;
        newAsm->aname.build = 0;
        newAsm->aname.revision = 0;
        newAsm->referencedAssemblyStart = -1;
        newAsm->referencedAssemblyCount = 0;

        // Using this BNM can check is assembly generated by it
        newImg->nameToClassHashTable = (decltype(newImg->nameToClassHashTable)) -0x424e4d;

        // Add assembly to list
        Assembly$$GetAllAssemblies()->push_back(newAsm);

        LOGIBNM(OBFUSCATE_BNM("Added new assembly: [%s]"), cls->dllName);

        return newImg;
    }

    // Check is class type generated by BNM
    bool isBNMType(IL2CPP::Il2CppType *type) {
        if (CheckObj(type->data.dummy)) return ((BNMTypeData *)type->data.dummy)->bnm == -0x424e4d;
        return false;
    }

    // Hook from type to prevent il2cpp from crashes when it trying to get class from type generated by BNM
    IL2CPP::Il2CppClass *Class$$FromIl2CppType(IL2CPP::Il2CppType *type) {
        // Check is type valid
        if (!type) return nullptr;

        // Check is type generated by BNM
        if (isBNMType(type)) return ((BNMTypeData *)type->data.dummy)->cls;

        return old_Class$$FromIl2CppType(type);
    }

    // Hook from name to prevent il2cpp from crashes when it trying to find class generated by BNM
    IL2CPP::Il2CppClass *Class$$FromName(IL2CPP::Il2CppImage *image, const char *namespaze, const char *name) {
        // Check is image valid
        if (!image) return nullptr;

        IL2CPP::Il2CppClass *ret = nullptr;

        // Check if the image is generated by BNM
        if (image->nameToClassHashTable != (decltype(image->nameToClassHashTable))-0x424e4d)
            ret = old_Class$$FromName(image, namespaze, name);

        // If by BNM, try find class
        if (!ret) BNMClassesMap.forEachByImage(image, [namespaze, name, &ret](IL2CPP::Il2CppClass *BNM_class) -> bool {
                if (!strcmp(namespaze, BNM_class->namespaze) && !strcmp(name, BNM_class->name)) {
                    ret = BNM_class;
                    // Found, we can break for
                    return true;
                }
                return false;
            });

        // Return null or found class
        return ret;
    }

    // Need due Image and Assembly in 2017.x- has index instead of pointer to Image and Assembly
#if UNITY_VER <= 174
    IL2CPP::Il2CppImage *new_GetImageFromIndex(IL2CPP::ImageIndex index) {

        // Index lower than 0 is BNM image
        if (index < 0) {
            IL2CPP::Il2CppImage *ret = nullptr;

            // Iterate all images and check is index is same
            BNMClassesMap.forEach([index, &ret](IL2CPP::Il2CppImage *img, const std::vector<IL2CPP::Il2CppClass *> &classes) -> bool {
                if (img->assemblyIndex == index) {
                    ret = img;
                    return true;
                }
                return false;
            });

            // Return null or found image
            return ret;
        }

        return old_GetImageFromIndex(index);
    }
    // All requests redirected to BNM and they are processed by it
    // In unity 2017 and lower name stored as metadata index so we can't use it
    // But we can check name by images
    IL2CPP::Il2CppAssembly *Assembly$$Load(const char *name) {
        auto LoadedAssemblies = Assembly$$GetAllAssemblies();

        for (auto assembly : *LoadedAssemblies) {

            // Get image from assembly
            auto image = new_GetImageFromIndex(assembly->imageIndex);

            // Check is name is same
            if (!strcmp(image->name, name) || !strcmp(image->nameNoExt, name)) return assembly;
        }

        // Nothing found
        return nullptr;
    }
#endif
    void InitNewClasses() {
        if (!classes4Add) return;
        for (auto& klass : *classes4Add) {
            IL2CPP::Il2CppImage *curImg = nullptr;

            // Check is class already exist in il2cpp
            {
                LoadClass existLS;

                DO_API(IL2CPP::Il2CppImage *, il2cpp_assembly_get_image, (const IL2CPP::Il2CppAssembly *));

                auto assemblies = BNM_Internal::Assembly$$GetAllAssemblies();

                // Try find image
                for (auto assembly : *assemblies) {
                    auto image = il2cpp_assembly_get_image(assembly);
                    if (!strcmp(klass->dllName, image->nameNoExt)) {
                        curImg = image;
                        break;
                    }
                }

                // Check is image found
                if (curImg) {

                    // Get all types of image
                    ClassVector classes;
                    BNM_Internal::Image$$GetTypes(curImg, false, &classes);

                    // Try find type
                    for (auto cls : classes) {
                        if (!cls) continue;

                        // Init class if it not initialized
                        BNM_Internal::Class$$Init(cls);

                        // Check is new class already exist
                        if (!strcmp(cls->name, klass->name) && !strcmp(cls->namespaze, klass->namespaze)) {
                            existLS = cls;
                            break;
                        }
                    }

                    // Clear classes vector
                    classes.clear(); classes.shrink_to_fit();

                } else curImg = makeImage(klass); // Make new image for new class

                // If exist warn and set class and type
                if (existLS) {
                    LOGWBNM(OBFUSCATE_BNM("%s already exist, it can't be added it to il2cpp! Please check code."), existLS.str().c_str());
                    // Just in case
                    klass->thisClass = existLS.klass;
                    klass->type = existLS;
                    continue;
                }
            }


            // Make types for new classes
            auto typeByVal = BNM_I2C_NEW(Il2CppType);
            typeByVal->type = IL2CPP::Il2CppTypeEnum::IL2CPP_TYPE_CLASS;
            typeByVal->attrs = 0x1; // Public
            typeByVal->pinned = 0;
            typeByVal->byref = 0;
            typeByVal->num_mods = 0;

            auto typeThis = BNM_I2C_NEW(Il2CppType);
            typeThis->type = IL2CPP::Il2CppTypeEnum::IL2CPP_TYPE_CLASS;
            typeThis->attrs = 0x1; // Public
            typeThis->pinned = 0;
            typeThis->byref = 1;
            typeThis->num_mods = 0;

            // Make BNMTypeData for getting class from type
            auto bnmTypeData = new BNMTypeData();
            typeByVal->data.dummy = (void *)bnmTypeData; // For il2cpp::vm::Class::FromIl2CppType
            typeThis->data.dummy = (void *)bnmTypeData; // For il2cpp::vm::Class::FromIl2CppType

            // Get parent class
            IL2CPP::Il2CppClass *parent = LoadClass(klass->baseNamespace, klass->baseName).GetIl2CppClass();
            if (!parent) parent = GetType<IL2CPP::Il2CppObject *>().ToIl2CppClass();

            // Need for interfaces, but them not fully implemented yet
            std::vector<IL2CPP::Il2CppRuntimeInterfaceOffsetPair> newInterOffsets;
            if (parent->interfaceOffsets)
                for (uint16_t i = 0; i < parent->interface_offsets_count; ++i)
                    newInterOffsets.push_back(parent->interfaceOffsets[i]);

            // Need for overriding virtual methods, but this not fully implemented yet
            std::vector<IL2CPP::VirtualInvokeData> newVTable;
            for (uint16_t i = 0; i < parent->vtable_count; ++i) newVTable.push_back(parent->vtable[i]);

            // Generate all new methods
            const IL2CPP::MethodInfo **methods = nullptr;
            if (!klass->methods4Add.empty()) {
                // Check is need add empty, default .ctor to class
                // Default constructor is calling by il2cpp::vm::Runtime::ObjectInitException
                bool needDefaultConstructor = std::none_of(klass->methods4Add.begin(), klass->methods4Add.end(), [](NEW_CLASSES::NewMethod *met) {
                    return !strcmp(met->name, OBFUSCATE_BNM(".ctor")) && met->argsCount == 0;
                });

                // Create methods array
                methods = (const IL2CPP::MethodInfo **) calloc(klass->methods4Add.size() + needDefaultConstructor, sizeof(IL2CPP::MethodInfo *));

                // Generate all methods
                for (int i = 0; i < klass->methods4Add.size(); ++i) {
                    auto &method = klass->methods4Add[i];
                    // Create new MethodInfo
                    method->thisMethod = BNM_I2C_NEW(MethodInfo);

                    // Set method address
                    method->thisMethod->methodPointer = (IL2CPP::Il2CppMethodPointer)method->address;

                    // Set invoker method address
                    method->thisMethod->invoker_method = (IL2CPP::InvokerMethod)method->invoker;

                    // Set parameters count
                    method->thisMethod->parameters_count = method->argsCount;

                    // Create method name
                    auto len = strlen(method->name) + 1;
                    method->thisMethod->name = new char[len];
                    memset((void *)method->thisMethod->name, 0, len);
                    strcpy((char *)method->thisMethod->name, method->name);

                    // Set method flags
                    method->thisMethod->flags = 0x0006 | 0x0080; // PUBLIC | HIDE_BY_SIG
                    if (method->isStatic) method->thisMethod->flags |= 0x0010; // |= STATIC

                    // BNM don't support generic methods
                    method->thisMethod->is_generic = false;

                    // Set return type
                    method->thisMethod->return_type = method->retType.ToIl2CppType();

                    // Generate parameters
                    if (method->argsCount) {
#if UNITY_VER < 212
                        // Create new parameters array and set
                        method->thisMethod->parameters = (IL2CPP::ParameterInfo *)calloc(method->argsCount, sizeof(IL2CPP::ParameterInfo));

                        // Get first parameter
                        auto newParam = (IL2CPP::ParameterInfo *)method->thisMethod->parameters;

                        // Generate parameters
                        for (int p = 0; p < method->argsCount; ++p) {

                            // Get len of new name
                            len = (OBFUSCATES_BNM("arg") + std::to_string(p)).size();

                            // Create name
                            newParam->name = new char[len + 1];
                            memset((void *)newParam->name, 0, len + 1);
                            strcat((char *)newParam->name, OBFUSCATE_BNM("arg"));
                            strcpy((char *)newParam->name, std::to_string(p).c_str());

                            // Set parameter index
                            newParam->position = p;

                            // Try set parameter type
                            if (!method->argTypes.empty() && p < method->argTypes.size()) {
                                newParam->parameter_type = method->argTypes[p].ToIl2CppType();
                                newParam->token = newParam->parameter_type->attrs | p;
                            } else {
                                newParam->parameter_type = nullptr;
                                newParam->token = p;
                            }
                            // Next parameter
                            ++newParam;
                        }
#else
                        // Create new parameters array
                        auto **params = new IL2CPP::Il2CppType*[method->argsCount];
                        // Set parameters
                        method->thisMethod->parameters = (const IL2CPP::Il2CppType **)params;

                        // Generate parameters
                        for (int p = 0; p < method->argsCount; ++p) {

                            // Create type
                            auto newParam = BNM_I2C_NEW(Il2CppType);

                            // Copy if can
                            if (p < method->argTypes.size())
                                memcpy(newParam, method->argTypes[p].ToIl2CppType(), sizeof(IL2CPP::Il2CppType));

                            // Set
                            params[p] = newParam;
                        }
#endif
                    }
#if UNITY_VER >= 212
                    else {
                        // We can't normally without hooks set args name, because names moved to metadata
                        method->thisMethod->methodMetadataHandle = nullptr;
                    }
#endif
                    methods[i] = method->thisMethod;
                }
                // Make dummy default constructor
                if (needDefaultConstructor) {
                    auto method = BNM_I2C_NEW(MethodInfo);
                    method->name = new char[6];
                    memset((void *)method->name, 0, 6);
                    strcpy((char *)method->name, OBFUSCATE_BNM(".ctor"));
                    method->parameters_count = 0;
                    method->parameters = nullptr;
                    method->return_type = GetType<void>().ToIl2CppType();
                    method->is_generic = false;
                    method->flags = 0x0006 | 0x0080; // PUBLIC | HIDE_BY_SIG
                    method->methodPointer = (IL2CPP::Il2CppMethodPointer) DefaultConstructor;
                    method->invoker_method = (IL2CPP::InvokerMethod) DefaultConstructorInvoke;
                    methods[klass->methods4Add.size()] = method;
                }
            }
#if UNITY_VER > 174
#define kls klass
#define typeSymbol *
#else
#define kls declaring_type
#define typeSymbol
#endif

            // Create new class
            klass->thisClass = (IL2CPP::Il2CppClass *)malloc(sizeof(IL2CPP::Il2CppClass) + newVTable.size() * sizeof(IL2CPP::VirtualInvokeData));

            // Set methods if them exists
            if (!klass->methods4Add.empty()) {
                // Set new generated class
                for (int i = 0; i < klass->methods4Add.size(); ++i)
                    ((IL2CPP::MethodInfo *)methods[i])->kls = klass->thisClass;

                // Set method count
                klass->thisClass->method_count = klass->methods4Add.size();

                // Set method array
                klass->thisClass->methods = methods;

                // Clear methods4Add array
                klass->methods4Add.clear(); klass->methods4Add.shrink_to_fit();
            } else {
                klass->thisClass->method_count = 0;
                klass->thisClass->methods = nullptr;
            }
            // Set parent
            klass->thisClass->parent = parent;

            // Generate fields
            klass->thisClass->field_count = klass->fields4Add.size();
            if (klass->thisClass->field_count > 0) {
                // Create fields array
                auto fields = (IL2CPP::FieldInfo *)calloc(klass->thisClass->field_count, sizeof(IL2CPP::FieldInfo));

                // Get first field
                IL2CPP::FieldInfo *newField = fields;
                if (!klass->fields4Add.empty()) {
                    for (auto &field : klass->fields4Add) {
                        // Create name
                        auto len = strlen(field->name);
                        newField->name = new char[len];
                        memset((void *)newField->name, 0, len);
                        strcpy((char *)newField->name, field->name);

                        // Copy type
                        newField->type = BNM_I2C_NEW(Il2CppType, *field->type.ToIl2CppType());

                        // Add visibility flags
                        ((IL2CPP::Il2CppType*)newField->type)->attrs |= field->attributes; // PUBLIC and STATIC if static

                        // Make token
                        newField->token = newField->type->attrs | field->attributes;

                        // Set new generated class
                        newField->parent = klass->thisClass;

                        // Set offset
                        newField->offset = field->offset;

                        // Next field
                        newField++;
                    }
                    // Clear fields4Add array
                    klass->fields4Add.clear(); klass->fields4Add.shrink_to_fit();

                    // Set staticFieldsAddress
                    klass->thisClass->static_fields = (void *)klass->staticFieldsAddress;

                    // Set staticFieldsSize
                    klass->thisClass->static_fields_size = klass->staticFieldOffset;
                }
                klass->thisClass->fields = fields;
            } else {
                klass->thisClass->static_fields_size = 0;
                klass->thisClass->static_fields = nullptr;
                klass->thisClass->fields = nullptr;
            }

            // Make type hierarchy
            klass->thisClass->typeHierarchyDepth = parent->typeHierarchyDepth + 1;
            klass->thisClass->typeHierarchy = (IL2CPP::Il2CppClass **)calloc(klass->thisClass->typeHierarchyDepth, sizeof(IL2CPP::Il2CppClass *));
            memcpy(klass->thisClass->typeHierarchy, parent->typeHierarchy, parent->typeHierarchyDepth * sizeof(IL2CPP::Il2CppClass *));
            klass->thisClass->typeHierarchy[klass->thisClass->typeHierarchyDepth - 1] = klass->thisClass;

            // Set image
            klass->thisClass->image = curImg;

            // Create name
            auto len = strlen(klass->name) + 1;
            klass->thisClass->name = new char[len];
            memset((void *)klass->thisClass->name, 0, len);
            strcpy((char *)klass->thisClass->name, klass->name);

            // Create namespace
            len = strlen(klass->namespaze) + 1;
            klass->thisClass->namespaze = new char[len];
            memset((void *)klass->thisClass->namespaze, 0, len);
            strcpy((char *)klass->thisClass->namespaze, klass->namespaze);

            // Set types
            klass->thisClass->byval_arg = typeSymbol typeByVal;
            klass->thisClass->this_arg = typeSymbol typeThis;
#undef kls
#undef typeSymbol
            // This is for inner classes, but BNM can't create inner classes
            klass->thisClass->declaringType = nullptr;

            // Copy parent flags and remove ABSTRACT flag is exists
            klass->thisClass->flags = klass->thisClass->parent->flags & ~0x00000080; // TYPE_ATTRIBUTE_ABSTRACT

            // Set classes
            klass->thisClass->element_class = klass->thisClass;
            klass->thisClass->castClass = klass->thisClass;
#if UNITY_VER > 174
            klass->thisClass->klass = klass->thisClass;
#endif
            // Init sizes
            klass->thisClass->native_size = -1;
            klass->thisClass->element_size = 0;
            klass->thisClass->actualSize = klass->size;
            klass->thisClass->instance_size = klass->size;

            // Set vtable
            klass->thisClass->vtable_count = newVTable.size();
            for (int i = 0; i < newVTable.size(); ++i) klass->thisClass->vtable[i] = newVTable[i];
            newVTable.clear(); newVTable.shrink_to_fit();

            // Set interface offsets
            klass->thisClass->interface_offsets_count = newInterOffsets.size();
            klass->thisClass->interfaceOffsets = (IL2CPP::Il2CppRuntimeInterfaceOffsetPair *)(calloc(newInterOffsets.size(), sizeof(IL2CPP::Il2CppRuntimeInterfaceOffsetPair)));
            for (int i = 0; i < newInterOffsets.size(); ++i) klass->thisClass->interfaceOffsets[i] = newInterOffsets[i];
            newInterOffsets.clear(); newInterOffsets.shrink_to_fit();

            // Set interfaces
            if (!klass->interfaces.empty()) {
                klass->thisClass->interfaces_count = klass->interfaces.size();
                klass->thisClass->implementedInterfaces = (IL2CPP::Il2CppClass **)calloc(klass->interfaces.size(), sizeof(IL2CPP::Il2CppClass *));
                for (int i = 0; i < klass->interfaces.size(); ++i) klass->thisClass->implementedInterfaces[i] = klass->interfaces[i].ToIl2CppClass();
                klass->interfaces.clear(); klass->interfaces.shrink_to_fit();
            } else {
                klass->thisClass->interfaces_count = 0;
                klass->thisClass->implementedInterfaces = nullptr;
            }

            // Prevent il2cpp from calling LivenessState::TraverseGCDescriptor for class
            klass->thisClass->gc_desc = nullptr;

            // BNM don't support generic classes creating
            klass->thisClass->generic_class = nullptr;
            klass->thisClass->genericRecursionDepth = 1;

            // Different initialization
            klass->thisClass->initialized = 1;
#if UNITY_VER > 182
            klass->thisClass->initialized_and_no_error = 1;
            klass->thisClass->initializationExceptionGCHandle = 0;
#if UNITY_VER < 212
            klass->thisClass->has_initialization_error = 0;
#endif
            klass->thisClass->naturalAligment = 0;
#endif
            klass->thisClass->init_pending = 0;
#if UNITY_VER < 202
            // No generic
            klass->thisClass->genericContainerIndex = -1;
#else
            // No generic
            klass->thisClass->genericContainerHandle = nullptr;
            klass->thisClass->typeMetadataHandle = nullptr;
#endif
#if UNITY_VER < 211
            klass->thisClass->valuetype = 1; // I can set to 0, but there are some other places where it using in il2cpp
#endif
            // Some other variables that need set
            klass->thisClass->interopData = nullptr;
            klass->thisClass->nestedTypes = nullptr;
            klass->thisClass->properties = nullptr;
            klass->thisClass->rgctx_data = nullptr;
            klass->thisClass->has_references = 0;
            klass->thisClass->has_finalize = 0;
            klass->thisClass->size_inited = klass->thisClass->is_vtable_initialized = 1;
            klass->thisClass->has_cctor = 0;
            klass->thisClass->enumtype = 0;
            klass->thisClass->minimumAlignment = 8;
            klass->thisClass->is_generic = 0;
            klass->thisClass->rank = 0;
            klass->thisClass->nested_type_count = 0;
            klass->thisClass->thread_static_fields_offset = 0;
            klass->thisClass->thread_static_fields_size = -1;
            klass->thisClass->cctor_started = 0;
#if UNITY_VER >= 203
            klass->thisClass->size_init_pending = 0;
#endif
#if UNITY_VER < 212
            klass->thisClass->cctor_finished = 0;
#endif
            klass->thisClass->cctor_thread = 0;

            // Set bnmTypeData class for getting this class from type
            bnmTypeData->cls = klass->thisClass;

            // Add class to generated classes map
            BNMClassesMap.addClass(curImg, klass->thisClass);

            // Get mono type
            klass->type = LoadClass(klass->thisClass);

            LOGIBNM(OBFUSCATE_BNM("[InitNewClasses] Added new class (%p): [%s]::[%s] parent is [%s]::[%s] to [%s]"), klass->thisClass, klass->thisClass->namespaze, klass->thisClass->name, parent->namespaze, parent->name, klass->thisClass->image->name);
        }
        // Clear and free classes4Add
        classes4Add->clear(); classes4Add->shrink_to_fit();
        delete classes4Add;
        classes4Add = nullptr;
    }
#endif
    void Image$$GetTypes(IL2CPP::Il2CppImage *image, bool, ClassVector *target) {
        // Check image and target
        if (!image || !target) return;

        // Get non BNM classes
        if (image->nameToClassHashTable != (decltype(image->nameToClassHashTable))-0x424e4d) {
            if (HasImageGetCls) {
                // BNM prefer to use il2cpp_image_get_class
                // Easier get it than find Image$$GetTypes
                DO_API(IL2CPP::Il2CppClass *, il2cpp_image_get_class, (IL2CPP::Il2CppImage *, decltype(image->typeCount)));

                auto typeCount = image->typeCount;

                for (decltype(image->typeCount) i = 0; i < typeCount; ++i) {
                    // Get class
                    auto type = il2cpp_image_get_class(image, i);

                    // Skip <Module>
                    if (OBFUSCATES_BNM("<Module>") == type->name) continue;

                    // Add class
                    target->push_back(type);
                }
            } else old_Image$$GetTypes(image, false, target);
        }

#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
        // Get BNM classes
        BNMClassesMap.forEachByImage(image, [&target](IL2CPP::Il2CppClass *BNM_class) -> bool {
            target->push_back(BNM_class);
            return false;
        });
#endif
    }

    // Get some methods and hook them
    void InitIl2cppMethods() {
#if defined(__ARM_ARCH_7A__) || defined(__aarch64__)
        int count = 1;
#elif defined(__i386__) || defined(__x86_64__)
        // x86 has one call before method code starts
        int count = 2;
#endif


        //! il2cpp::vm::Class::Init GET
        if (!Class$$Init) {
            // Path:
            // il2cpp_array_new_specific ->
            // il2cpp::vm::Array::NewSpecific ->
            // il2cpp::vm::Class::Init
            Class$$Init = (decltype(Class$$Init))  HexUtils::FindNextJump(HexUtils::FindNextJump((BNM_PTR) BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_array_new_specific")), count), count);
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Class::Init in lib: %p"), offsetInLib((void *)Class$$Init));
        }


        //! il2cpp_image_get_class CHECK (Unity 2018+)
        {
            DO_API(void,il2cpp_image_get_class,());
            HasImageGetCls = il2cpp_image_get_class != nullptr;
        }


        //! il2cpp::vm::Image::GetTypes HOOK AND GET (OR ONLY GET)
        if (!old_Image$$GetTypes && !HasImageGetCls) {
            DO_API(const IL2CPP::Il2CppImage *, il2cpp_get_corlib, ());
            DO_API(IL2CPP::Il2CppClass *, il2cpp_class_from_name, (const IL2CPP::Il2CppImage *, const char *, const char *));
            auto assemblyClass = il2cpp_class_from_name(il2cpp_get_corlib(), OBFUSCATE_BNM("System.Reflection"), OBFUSCATE_BNM("Assembly"));
            BNM_PTR GetTypesAdr = LoadClass(assemblyClass).GetMethodByName(OBFUSCATE_BNM("GetTypes"), 1).GetOffset(); // We can use LoadClass here by Il2CppClass, because for methods we need only it.
            const int sCount
#if UNITY_VER >= 211
                    = count;
#elif UNITY_VER > 174
                    = count + 1;
#else
            = count + 2;
#endif
            // Path:
            // System.Reflection.Assembly.GetTypes(bool) ->
            // il2cpp::icalls::mscorlib::System::Reflection::Assembly::GetTypes ->
            // il2cpp::icalls::mscorlib::System::Module::InternalGetTypes ->
            // il2cpp::vm::Image::GetTypes
            auto Image$$GetTypes_t = HexUtils::FindNextJump(HexUtils::FindNextJump(HexUtils::FindNextJump(GetTypesAdr, count), sCount), count);
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
            HOOK(Image$$GetTypes_t, Image$$GetTypes, old_Image$$GetTypes);
#else
            old_Image$$GetTypes = (decltype(old_Image$$GetTypes)) Image$$GetTypes_t;
#endif
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Image::GetTypes in lib: %p"), offsetInLib((void *)Image$$GetTypes_t));
        } else if (HasImageGetCls) {
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] game has il2cpp_image_get_class. BNM will use it"));
        }
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES

        //! il2cpp::vm::Class::FromIl2CppType HOOK
        if (!old_Class$$FromIl2CppType) {
            // Path:
            // il2cpp_class_from_type ->
            // il2cpp::vm::Class::FromIl2CppType
            auto from_type_adr = HexUtils::FindNextJump((BNM_PTR) BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_class_from_type")), count);
            HOOK(from_type_adr, Class$$FromIl2CppType, old_Class$$FromIl2CppType);
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Class::FromIl2CppType in lib: %p"), offsetInLib((void *)from_type_adr));
        }


        //! il2cpp::vm::Image::ClassFromName HOOK
        if (!old_Class$$FromName) {
            // Path:
            // il2cpp::vm::Class::FromName ->
            // il2cpp::vm::Image::ClassFromName
            auto from_name_adr = HexUtils::FindNextJump(HexUtils::FindNextJump((BNM_PTR) BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_class_from_name")), count), count);
            HOOK(from_name_adr, Class$$FromName, old_Class$$FromName);
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Class::FromName in lib: %p"), offsetInLib((void *)from_name_adr));
        }
#if UNITY_VER <= 174

        //! il2cpp::vm::MetadataCache::GetImageFromIndex HOOK
        if (!old_GetImageFromIndex) {
            // Path:
            // il2cpp_assembly_get_image ->
            // il2cpp::vm::Assembly::GetImage ->
            // il2cpp::vm::MetadataCache::GetImageFromIndex
            auto GetImageFromIndexOffset = HexUtils::FindNextJump(HexUtils::FindNextJump((BNM_PTR)BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_assembly_get_image")), count), count);
            HOOK(GetImageFromIndexOffset, new_GetImageFromIndex, old_GetImageFromIndex);
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::MetadataCache::GetImageFromIndex in lib: %p"), offsetInLib((void *)GetImageFromIndexOffset));
        }

        //! il2cpp::vm::Assembly::Load REPLACE
        static void *old_AssemblyLoad = nullptr;
        if (!old_AssemblyLoad) {
            // Path:
            // il2cpp_domain_assembly_open ->
            // il2cpp::vm::Assembly::Load
            BNM_PTR AssemblyLoadOffset = HexUtils::FindNextJump((BNM_PTR)BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_domain_assembly_open")), count);
            HOOK(AssemblyLoadOffset, Assembly$$Load, old_AssemblyLoad);
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Assembly::Load in lib: %p"), offsetInLib((void *)AssemblyLoadOffset));
        }

#endif
#endif

        //! il2cpp::vm::Assembly::GetAllAssemblies GET
        if (!Assembly$$GetAllAssemblies) {
#ifdef BNM_USE_APPDOMAIN
            DO_API(IL2CPP::Il2CppImage *, il2cpp_get_corlib, ());
            DO_API(IL2CPP::Il2CppClass *, il2cpp_class_from_name, (IL2CPP::Il2CppImage *, const char *, const char *));
            auto assemblyClass = il2cpp_class_from_name(il2cpp_get_corlib(), OBFUSCATE_BNM("System"), OBFUSCATE_BNM("AppDomain"));
            auto getAssembly = LoadClass(assemblyClass).GetMethodByName(OBFUSCATE_BNM("GetAssemblies"), 1);
            if (getAssembly) {
                const int sCount
#if !defined(__aarch64__) && UNITY_VER >= 211
                    = count;
#else
                    = count + 1;
#endif
                // Path:
                // System.AppDomain.GetAssemblies(bool) ->
                // il2cpp::icalls::mscorlib::System::AppDomain::GetAssemblies ->
                // il2cpp::vm::Assembly::GetAllAssemblies
                BNM_PTR GetAssembliesAdr = HexUtils::FindNextJump(getAssembly.GetOffset(), count);
                Assembly$$GetAllAssemblies = (AssemblyVector *(*)())(HexUtils::FindNextJump(GetAssembliesAdr, sCount));
                LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Assembly::GetAllAssemblies by AppDomain in lib: %p"), offsetInLib((void *)Assembly$$GetAllAssemblies));
            } else {
#endif
            // Path:
            // il2cpp_domain_get_assemblies ->
            // il2cpp::vm::Assembly::GetAllAssemblies
            auto adr = (BNM_PTR) BNM_dlsym(dlLib, OBFUSCATE_BNM("il2cpp_domain_get_assemblies"));
            Assembly$$GetAllAssemblies = (AssemblyVector *(*)())(HexUtils::FindNextJump(adr, count));
            LOGDBNM(OBFUSCATE_BNM("[InitIl2cppMethods] il2cpp::vm::Assembly::GetAllAssemblies by domain in lib: %p"), offsetInLib((void *)Assembly$$GetAllAssemblies));
#ifdef BNM_USE_APPDOMAIN
            }
#endif
        }
    }
    void BNM_il2cpp_init(const char *domain_name) {
        old_BNM_il2cpp_init(domain_name);

        InitIl2cppMethods(); // Get some methods and hook them
#if __cplusplus >= 201703 && !BNM_DISABLE_NEW_CLASSES
        InitNewClasses();  // Make new classes and add them to il2cpp
#endif
        LibLoaded = true; // Set LibLoaded to true

        // Call il2cpp load event
        if (OnIl2CppLoadedEvent) {
            OnIl2CppLoadedEvent();

            // If user detach need to reattach otherwise game just crash
            BNM::AttachIl2Cpp();
        }
    }
#ifndef BNM_DISABLE_AUTO_LOAD
    [[maybe_unused]] __attribute__((constructor))
    void PrepareBNM() {

        // Try get lib at lib start
        auto lib = BNM_dlopen(OBFUSCATE_BNM("libil2cpp.so"), RTLD_LAZY);
        if (InitDlLib(lib)) return;
        else BNM_dlclose(lib);

        // Try get lib at background
        std::thread([]() {
            do {
                if (hardBypass) break;
                auto lib = BNM_dlopen(OBFUSCATE_BNM("libil2cpp.so"), RTLD_LAZY);
                if (InitDlLib(lib)) break;
                else BNM_dlclose(lib);
            } while (true);
        }).detach();
    }
#endif

    // Check is valid lib
    bool InitDlLib(void *dl, const char* path, bool external) {
        if (!dl) return false;
        void *init = BNM_dlsym(dl, OBFUSCATE_BNM("il2cpp_init"));
        // Get il2cpp_init method
        if (init) {
            Dl_info info;
            BNM_dladdr(init, &info);
            // Info about dll
            if (!path) {
                auto l = strlen(info.dli_fname) + 1;
                auto s = new char[l];
                memset((void *)s, 0, l);
                strcpy(s, info.dli_fname);
                LibAbsolutePath = s;
            } else LibAbsolutePath = path;

            // Set LibAbsoluteAddress
            LibAbsoluteAddress = (BNM_PTR)info.dli_fbase;

            // Hook il2cpp_init if non external
            if (!external) HOOK(init, BNM_il2cpp_init, old_BNM_il2cpp_init);

            // Set dlLib
            dlLib = dl;
        }
        return init;
    }
}
#undef DO_API